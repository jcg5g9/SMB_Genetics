---
title: "Analysis 2: Hierarchical population structure analysis"
author: "Joe Gunn"
date: "2022-07-28"
output: html_document
---

# Project: Population genetic structure and morphological differentiation between Northern Smallmouth Bass (<i>Micropterus dolomieu dolomieu</i>) and Neosho Smallmouth Bass (<i>M. d. velox</i>)
We investigated patterns of genetic (via microsatellites) and morphological diversity, differentiation, and structure across Smallmouth Bass populations (<i>Micropterus dolomieu</i>) in the Central Interior Highlands (CIH) of North America, including the two recognized subspecies: Northern Smallmouth Bass (<i>M. d. dolomieu</i>), which is native to the lower Ozark Highlands, and Neosho Smallmouth Bass (<i>M. d. velox</i>), which is endemic to tributaries of the Arkansas River Basin. We compared three independent combinations of starting parameters in the Bayesian clustering software program STRUCTURE to ascertain a robust picture of hierarchical genetic structure in the CIH. We paired these data with genetic diversity metrics (e.g., observed and expected heterozygosity and allelic richness) to determine relative amounts of variation across geographically separated populations. We then assessed differentiation in five morphometric and meristic traits. We ultimately aimed to validate or amend the taxonomic status of the Smallmouth Bass subspecies by revealing potential ecological and evolutionary divergence between them, with the hope that increased taxonomic resolution would provide insight into the presence and distribution of evolutionary significant and management units for a popular sportfish.

## Specific Aim: Hierarchical structure analysis with three independent methods
For this aim, we use Bayesian clustering analysis and genotypes from 14 microsatellite loci with STRUCTURE (see citation below in under "Programs Needed") to assess patterns hierarchical genetic structure among and within black bass species (i.e., Spotted Bass and Smallmouth Bass) and subspecies (i.e., Northern Smallmouth Bass and Neosho Smallmouth Bass) in the CIH. To maximize our ability to ascertain potentially complex or cryptic levels of genetic diversity, we employ and integrate three independent "methods" within STRUCTURE, which each use either different starting parameters for identifying genetic clusters or different inference techniques for determining the optimal number of clusters: 1) <i>default parameters</i> (default parameters in STRUCUTRE); 2) <i>Wang parameters</i> (parameters recommended by Wang (2017); and 3) <i>Puechmaille metrics</i> (optimal cluster inference method recommended by Puechmaille 2016).

## Phases of Analysis
### Phase 1: Genotype data preparation
### Phase 2: Structure analysis with default STRUCTURE parameters
### Phase 3: Structure analysis with Wang (2017) recommended STRUCTURE parameters
### Phase 4: Structure analysis with Puechmaille metrics inference 
### Phase 5: Principal Components Analysis

Programs needed:

STRUCTURE v.2.3.4. (Pritchard et al. 2000)

Citation:

Pritchard JK, Stephens M, Donnelly P. 2000. Inference of population structure using multilocus genotype data. Genetics 155: 945-959.

CLUMPP v.1.1.2 (Jakobsson and Rosenberg 2007)

Citation:

Jakobsson M, Rosenberg NA. 2007. CLUMPP: A cluster matching and permutation program for dealing with label switching and multimodality in analysis of population structure. Bioinformatics 23: 1801-1806.

We ran each hierarchical analysis in separate .Rmd files, which are found in the `code/` directory.

## Libraries needed for analysis
```{r}
library(tidyverse)
library(cowplot)
library(readxl)
library(writexl)
library(genepopedit)
```

## PHASE 1: GENOTYPE DATA PREPARATION
In this phase of the analysis, we convert the raw microsatellite genotype data (`../raw_data/genotype_data.xlsx`) into Genepop-compatible format, which is read by the software program STRUCTURE in all downstream analyses. We use the same exact genepop data for each independent analysis in STRUCTURE; thus, we generate a single genepop and subsequent structure file, which includes all samples representing all collection sites.

### STEP 1: Manually reformat Excel genotype data into genepop-compatible format.
In this step, we opted to reformat the raw Excel microsatellite genotype data by hand in Excel, given that we could not find a working R library and/or function that converts raw genotype tables into genepop format (i.e., we attempted to use the <i>genind_to_genepop()</i> function from the package <i>graph4lg</i>, but we could not get our genind to convert properly). We follwed the steps below exactly in Excel to convert our genotype data into Genepop format, and we saved the corresponding data as a text file in the working `data` directory.

#### 1a. Add a "," after each sample_id in the first column.

#### 1b. Insert a row above each new population in the data, and insert "pop" in the sample_id column in each empty row (the word "pop" should appear for each population)

##### 1c. Copy the header row of microsatellite locus IDs and transpose paste in a new Excel sheet; each locus ID should be listed in its own row (number of rows should be equal to numbrer of locus IDs)

##### 1d. Copy all genotype and label data from the original Excel file and paste in the row immediately below the list of locus IDs

##### 1e. Save the Excel sheet as a .xlsx and a .txt file, with a specification that it is a "genepop" file.

### STEP 2: Generate STRUCTURE formatted files from genepop format.
In this step, we read in, check, and convert the genepop file manually generated in STEP 1 above into a STRUCTURE formatted file. There are quite a few tricky and very specific formatting needs for the genepop text file before genepopedit will convert successfully. 

Follow Step 2a-2f closely to create a proper genepop format. Click on the text file manually here, in R Studio, and use Ctrl + F in R Studio to find and replace the necessary things.

In this step, we are reading in, checking, and converting the genepop file manually generated in STEP 1 above into a STRUCTURE formatted file. There are quite a few tricky and very specific formatting needs for the genepop text file before genepopedit will convert successfully. Follow Step 2a-2f closely to create a proper genepop format. Click on the text file manually here, in R Studio, and use Ctrl + F in R Studio to find and replace the necessary things.

### IMPORTANT NOTE ON DATA: genepopedit requires that sample names be in the format 'popname_01', 'popname_02', etc. where the 'popname' is a signifier for the population of origin for the sample, and the '01', etc. are numerical designations for the samples. 'popname' and the numeric must be separated by a "_", and there can only be a single "_". Otherwise, genepopedit will not read the sample's population of origin correctly. In the case of this project, we are clumping samples together by stream for STRUCTURE analysis to see if there is substructure mapped by stream. Many sample IDs in our dataset were not in the required format, so we added an additional column to the metadata set and associated processed data sets called "structure_ID", which gives a unique sample name in the proper structure format. This column can then be linked back to any other column in downstream analyses if we need to know which specific samples the results came from. 

#### 2a. All quotation marks were removed from the text file

#### 2b. All "," in the genepop text files were manually replaced with " ,  "

#### 2c. All "tabs" between six-digit alleles were were manually replaced with " " (a single space)

#### 2d. The top row designating the dataset combination was manually omitted

#### 2e. Any additional space at the bottom of the text file was removed

#### 2f. Generate STRUCTURE file from genepop file; run the Rmd chunk below.
Here it is important to not include the 'popgroup = ' unless it is explicitly necessary. Assigning popgroup to a dataframe with population names will cause the STRUCTURE input file to have word strings in the popdata column. Our experience is that STRUCTURE expects an integer here rather than a string, so best not to use popgroup.

##### Convert genepop to STRUCTURE format:`
```{r}
# Generate structure .txt file from genepop .txt file
genepop_structure("data/genepop_data/genepop.txt", 
                  locusnames = TRUE, 
                  path = "data/structure_data/input_data/structure.txt")
```

<b>Details on structure file for all black bass samples:</b> <br>
N<sub>pops</sub> = 43
N<sub>streams/lakes</sub> = 28

### STEP 3: Run preliminary genetic structure screen in STRUCTURE with K=28 possible clusters
In this step, we conduct a preliminary analysis in STRUCTURE, in which we set the number of possible clusters (<i>K</i> to 28, representing all stream, lake, or hatchery systems, to screen for broad levels of population structure. We use this analysis to assess the maximum number of genetic clusters and therefore inform all downstream independent analyses.

#### 3a: Generate batch list files and shell scripts for running STRUCTURE in parallel
In this step, we are creating batch lists of command line code to run STRUCTURE analyses in parallel. Each batch list contains a separate line of code to run a single replicate at an a priori determined number of populations (<i>K</i>, listed in the chunk above for each dataset). We run the analysis for 10 replicates at each <i>K</i>, e.g.:

structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_1
structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_2
structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_3
structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_4
structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_5
.
.
.
structure -K 1 -m mainparams -e extraparams -i structure_input.txt -o structure_output_1_10
structure -K 2 -m mainparams -e extraparams -i structure_input.txt -o structure_output_2_1
structure -K 2 -m mainparams -e extraparams -i structure_input.txt -o structure_output_2_2
.
.
.
where, in the output name, the first number represents the <i>K</i> value for the run, and the last number represents the replicate.

#### 3b. Generate batch list file; run the Rmd chunk below:
The Rmd chunk below generates a list of commands that contains the full cluster paths (/home/data/...) for necessary files.

##### Generate batch commands: `batch_cmd_lists/prelim_batch_cmd_list.txt`
```{r}
nk <- data.frame(c(1:28))
nreps <- data.frame(c(1:10))

cat("", file="code/batch_cmd_lists/prelim_batch_cmd_list.txt")

# Run loop to create file for storing commands
for(ii in 1:nrow(nk)) {

  for(aa in 1:nrow(nreps)) {
    
    structure_call <- paste("structure ")

    param_files <- paste(" -m /home/jcg5g9/data/SMB_Genetics/03_structure_analysis/data/structure_data/param_files/mainparams_prelim -e /home/jcg5g9/data/SMB_Genetics/03_structure_analysis/data/structure_data/param_files/extraparams_prelim")

    input <- paste(" -i /home/jcg5g9/data/SMB_Genetics/03_structure_analysis/data/structure_data/input_data/structure.txt")
  
    output <- paste(" -o /home/jcg5g9/data/SMB_Genetics/03_structure_analysis/data/structure_data/output_data/output_prelim/")
  
    cat(paste(structure_call, "-K ", nk[ii,], param_files, input, output,
            strsplit("prelim_structure.txt", "_structure.txt", fixed = TRUE)[[1]][1], "_", nk[ii,], "_", nreps[aa,], sep=""),
      "\n", 
      file = paste("code/batch_cmd_lists/prelim_batch_cmd_list.txt"),
      append = TRUE)
  }
}
```

#### 3c. Generate shell script; run the Rmd chunk below:

##### IMPORTANT NOTE: This shell script was generated on the server directly, and thus the Rmd chunk below does not need to be run to generate the file. This is purely to keep a record of each script file. 

##### Generate batch commands: `shell_scripts/prelim_structure.sh`
```{r}
#!/bin/bash
#-------------------------------------------------------------------------------
#  SBATCH CONFIG
#-------------------------------------------------------------------------------
## resources
#SBATCH --partition Lewis
#SBATCH --nodes=1
#SBATCH --ntasks=1  # used for MP#SBATCH -e error_%A_%a.err # Standard error codes, otherwise leav$
##SBATCH --cpus-per-task=12  # cores per task
#SBATCH --mem-per-cpu=16G  # memory per core (default is 1GB/core)
#SBATCH --time 2-00:00  # days-hours:minutes
#SBATCH --qos=normal
#SBATCH --array=23-220

## labels and outputs
#SBATCH --job-name=snolh_structure_jgunn
#
#SBATCH -o test_%A_%a.out # Standard output
#SBATCH -e error_%A_%a.err # Standard error

## notifications
#SBATCH --mail-user=jcg5g9@mail.missouri.edu  # email address for notifications
#SBATCH --mail-type=END,FAIL  # which type of notifications to send
#-------------------------------------------------------------------------------

#echo "### Starting at: $(date) ###"


# load packages
#module load rss/rss-2020
#module load structure/structure-2.3.4

#COMMANDA=`head -n ${SLURM_ARRAY_TASK_ID} ../batch_cmd_lists/prelim_batch_cmd_list.txt | tail -n 1`
#eval $COMMANDA


#echo "### Ending at: $(date) ###"
```

#### 3d: Prepare mainparam and extraparam files for STRUCTURE.
In this step, we are preparing the mainparam and extraparam input files for STRUCTURE so that they are unique to each analysis we are running.

##### 3d.1. Edit base mainparam STRUCTURE file (downloaded with STRUCTURE program) and generate a separate, unique mainparam file.

<b>mainparam file:</b> <br>
`../data/structure_data/param_files/mainparams_prelim` <br> 

###### 3d.1.1. Edit "maxpops" value to reflect the number of populations designated in Step 3b above. These values should be the following:

<b>Populations:</b> 28 <br>

###### 3d.1.2. Set the number of burn-in and MCMC iterations to run; these are the same for each analysis:

<b>Burn-in runs:</b> 500,000 <br>
<b>MCMC runs:</b> 1,000,000 <br>

###### 3d.1.3. Set the number of individuals.

<b>Individuals:</b> 766 <br>

###### 3d.1.4 Set the number of loci.

<b>Loci:</b> 14 <br>

###### 3d.1.5. Set 'ONEROWPERIND' to '0'

###### 3d.1.6. Set 'LABEL' to '1'

###### 3d.1.7. Set 'POPDATA' to '1'

###### 3d.1.8. Set 'POPFLAG' to '0'

##### 3d.2. Edit base extraparam STRUCTURE file (downloaded with STRUCTURE program).
We did not change any of the default settings in the extraparams file (most importantly, we used the default admixture model), so we only used a single extraparams file.

<b>extraparam file:</b> <br>
`../data/structure_data/param_files/extraparams` <br> 

### STEP 4: Population Structure Analysis with STRUCTURE

See `snolh_structure_analysis.Rmd` (Line 166) for programs needed for analysis.

#### 2a: Run STRUCTURE analysis using the input data generated in STEP 1. Navigate to `shell_scripts/` Be sure that all relative and full paths to all input files and output destination directories are set up properly (ideally, this is already done within this GitHub repo). This command line code assumes capability to run the code using SLURM or a SLURM-like cluster scheduling software.

Run `sbatch all_samples_all_snps_structure.sh`

#### 2b: Structure output files are generated and stored here: `../data/structure_data/output_data/all_samples_all_snps_structure_output/`.

#### 2c: Compress output directory into a zip file compatible with Structure Selector (Li and Liu 2017) or Structure Harvester (Earl and vonHoldt 2011) online

#### 2d: Submit zip directory to Structure Selector or Structure Harvester to extract summary results

#### 2e: Visualize STRUCTURE runs for all data combinations

##### 2e.1. Convert STRUCTURE files into aligned Q files compatible with analysis in the program CLUMPP (Jakobbson and Rosenberg 2007); run the rmd chunk below.

##### Convert STRUCTURE files to aligned Q files for CLUMPP: 
```{r}
# Get a list of structure files for each data combination
all_sfiles <- list.files("../data/structure_data/output_data/all_samples_all_snps_structure_output/", 
                               full.names = T)

# Extract q value information (ancestry proportions) from each run for each K value for each individual from the STRUCTURE output files in the directories listed above
all_Q <- readQ(all_sfiles)

# Tabulate information from the q lists
all_tab <- tabulateQ(all_Q)

# Summarize information from tabultions above
all_summary <- summariseQ(all_tab)

# Extract deltaK and associated summary information using Evanno method
all_evanno <- evannoMethodStructure(all_summary, returnplot = F)

# Set infinity and NA to zero arbitrarily
all_evanno$deltaK[all_evanno$deltaK == "Inf"] <- 0
all_evanno$deltaK[is.na(all_evanno$deltaK)] <- 0

# Write Evanno table to Excel table for manuscript preparation.

## Convert to data frame
all_evanno <- as.data.frame(all_evanno)

## Write Excel file
write_xlsx(all_evanno, "../data/structure_data/deltak_data/all_deltak.xlsx")

# Align replicate runs for each K to correct label switching
all_align <- alignK(all_Q)
```


## ------------------------ END OF PHASE 1: GENOTYPE DATA PREPARATION -------------------------- ##

## PHASE 2: STRUCTURE ANALYSIS WITH DEFAULT STRUCTURE PARAMETERS

### Run the code: `code/02_default.Rmd`

## ------------------------ END OF PHASE 2: STRUCTURE ANALYSIS WITH DEFAULT STRUCTURE PARAMETERS -------------------------- ##

## PHASE 3: STRUCTURE ANALYSIS WITH WANG (2017) RECOMMENDED STRUCTURE PARAMETERS

### Run the code: `code/03_wang.Rmd`

## ------------------------ END OF PHASE 3: STRUCTURE ANALYSIS WITH WANG (2017) RECOMMENDED STRUCTURE PARAMETERS -------------------------- ##

## PHASE 4: STRUCTURE ANALYSIS WITH PUECHMAILLE INFERENCE METRICS

### Run the code: `code/04_Puechmaille.Rmd`

## ------------------------ END OF PHASE 4: STRUCTURE ANALYSIS WITH PUECHMAILLE INFERENCE METRICS ---------- ##

## PHASE 5: PRINCIPAL COMPONENTS ANALYSIS
In this phase of analysis, we visualize and infer population hierarchical structure at the species, subspecies, and population level using an alternative, model-free principal components analysis (PCA)

## ------------------------ END OF PHASE 5: PRINCIPAL COMPONENTS ANALYSIS ----------- ##

## ------------------------ END OF ANALYSIS 2: HIERARCHICAL POPULATION STRUCTURE ANALYSIS ----------------------- ##

